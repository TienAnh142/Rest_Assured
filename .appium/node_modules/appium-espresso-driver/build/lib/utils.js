"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPackageInfoSync = exports.getPackageInfo = exports.updateDependencyLines = exports.requireOptions = exports.copyGradleProjectRecursively = exports.qualifyActivityName = void 0;
const support_1 = require("appium/support");
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
let PACKAGE_INFO = null;
const MODULE_NAME = 'appium-espresso-driver';
/**
 * https://android.googlesource.com/platform/frameworks/base/+/master/tools/aapt/Resource.cpp#755
 *
 * @param {string} activityName
 * @param {string} packageName
 * @returns {string} The qualified activity name
 */
function qualifyActivityName(activityName, packageName) {
    // if either activity or package name is not set
    // or any of these contain wildcards then there is
    // no point in qualifying the activity name
    if ([activityName, packageName].some((name) => !name || lodash_1.default.includes(name, '*'))) {
        return activityName;
    }
    const dotPos = activityName.indexOf('.');
    if (dotPos > 0) {
        return activityName;
    }
    return `${packageName}${dotPos === 0 ? '' : '.'}${activityName}`;
}
exports.qualifyActivityName = qualifyActivityName;
/**
 * Recursively copy all files except build directories contents
 * @param {string} sourceBaseDir  directory to copy files from
 * @param {string} targetBaseDir directory to copy files to
 * @returns {Promise<void>}
 */
async function copyGradleProjectRecursively(sourceBaseDir, targetBaseDir) {
    // @ts-ignore it is ok to have the async callback
    await support_1.fs.walkDir(sourceBaseDir, true, async (itemPath, isDirectory) => {
        const relativePath = path_1.default.relative(sourceBaseDir, itemPath);
        const targetPath = path_1.default.resolve(targetBaseDir, relativePath);
        const isInGradleBuildDir = `${path_1.default.sep}${itemPath}`.includes(`${path_1.default.sep}build${path_1.default.sep}`);
        if (isInGradleBuildDir) {
            return false;
        }
        if (isDirectory) {
            await (0, support_1.mkdirp)(targetPath);
        }
        else {
            await support_1.fs.copyFile(itemPath, targetPath);
        }
        return false;
    });
}
exports.copyGradleProjectRecursively = copyGradleProjectRecursively;
function requireOptions(opts, requiredKeys = []) {
    const missingKeys = lodash_1.default.difference(requiredKeys, lodash_1.default.keys(opts));
    if (!lodash_1.default.isEmpty(missingKeys)) {
        throw new Error(`The following options are required: ${missingKeys}`);
    }
    return opts;
}
exports.requireOptions = requireOptions;
function updateDependencyLines(originalContent, dependencyPlaceholder, dependencyLines) {
    const configurationLines = originalContent.split('\n');
    const searchRe = new RegExp(`^\\s*//\\s*\\b${lodash_1.default.escapeRegExp(dependencyPlaceholder)}\\b`, 'm');
    const placeholderIndex = configurationLines.findIndex((line) => searchRe.test(line));
    if (placeholderIndex < 0) {
        return originalContent;
    }
    const placeholderLine = configurationLines[placeholderIndex];
    const indentLen = placeholderLine.length - lodash_1.default.trimStart(placeholderLine).length;
    configurationLines.splice(placeholderIndex + 1, 0, ...(dependencyLines
        .map((line) => `${' '.repeat(indentLen)}${line}`)));
    return configurationLines.join('\n');
}
exports.updateDependencyLines = updateDependencyLines;
/**
 * Fetches the module info from package.json
 *
 * @returns {Promise<Record<string, any>>} The full path to module's package.json and its payload
 * @throws {Error} If package.json cannot be found
 */
async function getPackageInfo() {
    if (PACKAGE_INFO) {
        return PACKAGE_INFO;
    }
    let currentDir = path_1.default.dirname(path_1.default.resolve(__filename));
    let isAtFsRoot = false;
    while (!isAtFsRoot) {
        const manifestPath = path_1.default.join(currentDir, 'package.json');
        try {
            if (await support_1.fs.exists(manifestPath)) {
                const manifestPayload = JSON.parse(await support_1.fs.readFile(manifestPath, 'utf8'));
                if (manifestPayload.name === MODULE_NAME) {
                    PACKAGE_INFO = {
                        manifestPath,
                        manifestPayload
                    };
                    return PACKAGE_INFO;
                }
            }
        }
        catch (ign) { }
        currentDir = path_1.default.dirname(currentDir);
        isAtFsRoot = currentDir.length <= path_1.default.dirname(currentDir).length;
    }
    throw new Error(`Cannot find the root folder of the ${MODULE_NAME} Node.js module`);
}
exports.getPackageInfo = getPackageInfo;
/**
 * Fetches the module info from package.json synchronously
 *
 * @returns {Record<string, any>} The full path to module's package.json and its payload
 * @throws {Error} If package.json cannot be found
 */
function getPackageInfoSync() {
    if (PACKAGE_INFO) {
        return PACKAGE_INFO;
    }
    let currentDir = path_1.default.dirname(path_1.default.resolve(__filename));
    let isAtFsRoot = false;
    while (!isAtFsRoot) {
        const manifestPath = path_1.default.join(currentDir, 'package.json');
        try {
            if (fs_1.default.existsSync(manifestPath)) {
                const manifestPayload = JSON.parse(fs_1.default.readFileSync(manifestPath, 'utf8'));
                if (manifestPayload.name === MODULE_NAME) {
                    PACKAGE_INFO = {
                        manifestPath,
                        manifestPayload
                    };
                    return PACKAGE_INFO;
                }
            }
        }
        catch (ign) { }
        currentDir = path_1.default.dirname(currentDir);
        isAtFsRoot = currentDir.length <= path_1.default.dirname(currentDir).length;
    }
    throw new Error(`Cannot find the root folder of the ${MODULE_NAME} Node.js module`);
}
exports.getPackageInfoSync = getPackageInfoSync;
//# sourceMappingURL=utils.js.map